use anyhow::{anyhow, Context as _};
use cargo_metadata as cm;
use duct::cmd;
use itertools::Itertools as _;
use quote::quote;
use std::{
    collections::{BTreeMap, HashMap, HashSet},
    env, fs,
    ops::Range,
    path::{Path, PathBuf},
};
use structopt::StructOpt;

#[derive(StructOpt)]
enum Opt {
    Doc {
        /// Path to Cargo.toml
        #[structopt(long, value_name("PATH"))]
        manifest_path: Option<PathBuf>,
    },
}

fn main() -> anyhow::Result<()> {
    match Opt::from_args() {
        Opt::Doc { manifest_path } => doc(manifest_path.as_deref()),
    }
}

fn doc(manifest_path: Option<&Path>) -> anyhow::Result<()> {
    let metadata = &cargo_metadata(manifest_path)?;

    let resolve = metadata.resolve.as_ref().expect("should be present");
    let resolve_root = resolve
        .root
        .as_ref()
        .with_context(|| "this is a virtual manifest")?;

    let extern_crate_names = {
        let explicit_names_in_toml = metadata[resolve_root]
            .dependencies
            .iter()
            .flat_map(|d| &d.rename)
            .collect::<HashSet<_>>();

        let cm::Node { deps, .. } = resolve
            .nodes
            .iter()
            .find(|cm::Node { id, .. }| id == resolve_root)
            .unwrap();

        deps.iter()
            .filter(|cm::NodeDep { dep_kinds, .. }| {
                dep_kinds
                    .iter()
                    .any(|cm::DepKindInfo { kind, .. }| *kind != cm::DependencyKind::Build)
            })
            .flat_map(|cm::NodeDep { name, pkg, .. }| {
                let extern_crate_name = if explicit_names_in_toml.contains(name) {
                    name
                } else {
                    &metadata[pkg].lib_or_proc_macro()?.name
                };
                Some((pkg, extern_crate_name))
            })
            .collect::<HashMap<_, _>>()
    };

    let lib = metadata[resolve_root]
        .lib_or_proc_macro()
        .with_context(|| format!("missing `lib|proc-macro` target in `{}`", resolve_root))?;

    let library_crates = library_crates(metadata);

    let mut tree = Tree::default();
    for (path, package, target) in &library_crates {
        tree.insert(path, package, target);
    }

    let mut generated = "// This file is automatically generated by `xtask`.\n".to_owned();
    generated += "\n";
    generated += "//! Re-exports the library crates for rustdoc.\n";
    generated += "//!\n";
    generated += "//! This crate itself is not intended to be used directly.\n";
    tree.expand(&|id| &extern_crate_names[id], &mut generated)?;
    generated = {
        let rustfmt_exe = PathBuf::from(
            env::var_os("CARGO").with_context(|| "missing `$CARGO` environment variable")?,
        )
        .with_file_name("rustfmt")
        .with_extension(env::consts::EXE_EXTENSION);
        let tempdir = tempfile::Builder::new()
            .prefix("qryxip-competitive-programming-library-xtask-")
            .tempdir()?;
        let path = tempdir.path().join("generated.rs");
        fs::write(&path, generated)?;
        cmd!(rustfmt_exe, "--edition", "2018", &path).run()?;
        let generated = fs::read_to_string(path)?;
        tempdir.close()?;
        generated
    };
    fs::write(&lib.src_path, generated)?;

    let markdown_dir = metadata.workspace_root.join("markdowns");
    fs::create_dir_all(&markdown_dir)
        .with_context(|| format!("could not create `{}`", markdown_dir.display()))?;
    for (_, package, target) in library_crates {
        let markdown = format!(
            "---\n\
             title: \"{} (<code>{}</code>)\"\n\
             documentation_of: //{}\n\
             ---\n\
             {}",
            package.name,
            target.name,
            target
                .src_path
                .strip_prefix(&metadata.workspace_root)
                .unwrap_or(&target.src_path)
                .display(),
            modify_doc_for_oj_verify(&target.read_crate_level_doc()?),
        );
        let markdown_path = markdown_dir.join(&package.name).with_extension("md");
        fs::write(&markdown_path, markdown)
            .with_context(|| format!("could not write `{}`", markdown_path.display()))?;
    }

    return Ok(());

    enum Tree<'cm> {
        Leaf(&'cm cm::PackageId, &'cm cm::Target),
        Joint(BTreeMap<&'cm str, Self>),
    }

    impl<'cm> Tree<'cm> {
        fn insert(
            &mut self,
            path: &[&'cm str],
            package: &'cm cm::Package,
            target: &'cm cm::Target,
        ) {
            match (self, path) {
                (Self::Joint(joint), []) => {
                    joint.insert(&target.name, Self::Leaf(&package.id, target));
                }
                (Self::Joint(joint), [segment, path @ ..]) => {
                    joint
                        .entry(segment)
                        .or_default()
                        .insert(path, package, target);
                }
                _ => panic!(),
            }
        }

        fn expand(
            &self,
            extern_crate_name: &impl Fn(&cm::PackageId) -> &'cm str,
            out: &mut String,
        ) -> anyhow::Result<()> {
            match self {
                Self::Leaf(package_id, target) => {
                    let doc = target.read_crate_level_doc()?;
                    if !doc.is_empty() {
                        *out += "#![doc=";
                        *out += &quote!(#doc).to_string();
                        *out += "]";
                    }
                    *out += "pub use ::";
                    *out += extern_crate_name(package_id);
                    *out += "::*;"
                }
                Self::Joint(joint) => {
                    for (segment, node) in joint {
                        *out += "pub mod ";
                        *out += segment;
                        *out += "{";
                        node.expand(extern_crate_name, out)?;
                        *out += "}";
                    }
                }
            }
            Ok(())
        }
    }

    impl Default for Tree<'_> {
        fn default() -> Self {
            Self::Joint(BTreeMap::new())
        }
    }
}

fn cargo_metadata(manifest_path: Option<&Path>) -> anyhow::Result<cm::Metadata> {
    let mut cmd = cm::MetadataCommand::new();
    if let Some(manifest_path) = manifest_path {
        cmd.manifest_path(manifest_path);
    }
    cmd.exec().map_err(|err| match err {
        cm::Error::CargoMetadata { stderr } => {
            anyhow!("{}", stderr.trim_start_matches("error: ").trim_end())
        }
        err => anyhow::Error::msg(err),
    })
}

fn crates_dir(workspace_root: &Path) -> PathBuf {
    workspace_root.join("crates")
}

fn library_crates(metadata: &cm::Metadata) -> Vec<(Vec<&str>, &cm::Package, &cm::Target)> {
    let crates_dir = &crates_dir(&metadata.workspace_root);

    metadata
        .workspace_members
        .iter()
        .flat_map(|ws_member| {
            let ws_member = &metadata[ws_member];
            let target = ws_member.lib_or_proc_macro()?;
            let src_path = dunce::canonicalize(&target.src_path).ok()?;
            let path1 = ws_member.manifest_path.strip_prefix(crates_dir).ok()?;
            let path2 = src_path.strip_prefix(crates_dir).ok()?;
            let common_path = itertools::zip(path1, path2)
                .filter(|(s1, s2)| s1 == s2)
                .map(|(segment, _)| segment.to_str().expect("this is from a JSON"))
                .collect();
            Some((common_path, ws_member, target))
        })
        .collect()
}

fn modify_doc_for_oj_verify(doc: &str) -> String {
    use pulldown_cmark::{CodeBlockKind, Event, Options, Parser, Tag};

    let mut doc = match doc {
        "" => "\n".to_owned(),
        doc => doc
            .lines()
            .map(|line| match line {
                "" => "\n".to_owned(),
                line => line.trim_start().to_owned() + "\n",
            })
            .join(""),
    };

    for (_, Range { start, .. }) in Parser::new_ext(&doc.clone(), Options::all())
        .into_offset_iter()
        .filter(|(event, _)| {
            matches!(
                event, Event::Start(Tag::CodeBlock(CodeBlockKind::Fenced(kind))) if kind.is_empty()
            )
        })
        .collect::<Vec<_>>()
        .into_iter()
        .rev()
    {
        let mut pos = start;
        while doc.as_bytes()[pos] == b'`' {
            pos += 1;
        }
        doc.insert_str(pos, "rust");
    }

    doc
}

trait PackageExt {
    fn lib_or_proc_macro(&self) -> Option<&cm::Target>;
}

impl PackageExt for cm::Package {
    fn lib_or_proc_macro(&self) -> Option<&cm::Target> {
        self.targets.iter().find(|cm::Target { kind, .. }| {
            [&["lib".to_owned()][..], &["proc-macro".to_owned()]].contains(&&**kind)
        })
    }
}

trait TargetExt {
    fn read_crate_level_doc(&self) -> anyhow::Result<String>;
}

impl TargetExt for cm::Target {
    fn read_crate_level_doc(&self) -> anyhow::Result<String> {
        let syn::File { attrs, .. } = syn::parse_file(&fs::read_to_string(&self.src_path)?)?;

        Ok(attrs
            .iter()
            .flat_map(syn::Attribute::parse_meta)
            .flat_map(|meta| match meta {
                syn::Meta::NameValue(syn::MetaNameValue {
                    path,
                    lit: syn::Lit::Str(lit_str),
                    ..
                }) if path.is_ident("doc") => Some(lit_str.value()),
                _ => None,
            })
            .join("\n"))
    }
}
