// This file is automatically generated by `cargo-online-judge-verification-helper-helper`.
//! Re-exports the library crates for rustdoc.
//!
//! This crate itself is not intended to be used directly.
pub mod graph {
    pub mod dijkstra {
        #![doc = " Performs Dijkstra's algorithm.\n\n # Example\n\n ```\n // [0] --1-> [1] --999-> [4]\n //            |           ↑\n //            1           1\n //            ↓           |\n //           [2] ---1--> [3]\n\n let start = 0;\n let graph = vec![\n     vec![(1, 1)],\n     vec![(2, 1), (4, 999)],\n     vec![(3, 1)],\n     vec![(4, 1)],\n     vec![],\n ];\n\n let costs = dijkstra::costs(\n     start,\n     |i| graph[i].iter().copied(),\n     vec![u64::max_value(); graph.len()],\n     |graph, i| &mut graph[i],\n );\n\n assert_eq!([0, 1, 2, 3, 4], *costs);\n ```"]
        pub use ::dijkstra::*;
    }
}
pub mod integer {
    pub mod gcd {
        #![doc = " Calculates a Greatest Common Divisor (GCD).\n\n ```\n assert_eq!(2, gcd::gcd(10, 2));\n assert_eq!(1, gcd::gcd(10, 3));\n assert_eq!(14, gcd::gcd(56, 42));\n ```"]
        pub use ::gcd::*;
    }
    pub mod montmort_number {
        #![doc = " Computes Montmort numbers.\n\n # Example\n\n ```\n assert_eq!(\n     vec![0usize, 0, 1, 2, 9, 44, 265, 1854, 14833, 133_496, 1_334_961],\n     montmort_number::montmort(10),\n );\n ```"]
        pub use ::montmort_number::*;
    }
    pub mod partition_point {
        #![doc = " Computes the index of the partition point.\n\n # Examples\n\n ```\n use partition_point::RangeBoundsExt as _;\n\n assert_eq!(1000, (0..1 << 30).partition_point(|n| n.to_string().len() <= 3));\n assert_eq!(100, (0..100).partition_point(|_| true));\n ```\n\n ```\n use partition_point::SliceExt as _;\n\n assert_eq!(5, [0, 0, 0, 0, 0, 1, 1].partition_point(|&x| x == 0));\n ```"]
        pub use ::partition_point::*;
    }
    pub mod xorshift {
        #![doc = " Xorshift.\n\n # Example\n\n ```\n use xorshift::Xorshift64;\n\n let mut xor64 = Xorshift64::new();\n let _: u64 = xor64.next_u64();\n let _: u64 = xor64.next_u64();\n let _: u64 = xor64.next_u64();\n ```"]
        pub use ::xorshift::*;
    }
}
pub mod io {
    pub mod buffered_print {
        pub use ::buffered_print::*;
    }
    pub mod input {
        pub use ::input::*;
    }
}
pub mod modulo {
    pub mod tonelli_shanks {
        #![doc = " Performs Tonelli–Shanks algorithm.\n\n # Example\n\n ```\n # use __acl_modint as acl_modint;\n use acl_modint::ModInt1000000007 as Mint;\n use tonelli_shanks::ModIntBaseExt as _;\n\n assert_eq!(Some(82_681_419.into()), Mint::new(42).sqrt());\n ```"]
        pub use ::tonelli_shanks::*;
    }
}
pub mod prime {
    pub mod miller_rabin {
        #![doc = " Performs Miller-Rabin test.\n\n # Example\n\n ```\n assert!(miller_rabin::is_prime(22_801_763_489));\n ```"]
        pub use ::miller_rabin::*;
    }
    pub mod rho {
        pub use ::rho::*;
    }
    pub mod sieve {
        #![doc = " A prime sieve.\n\n # Example\n\n ```\n use sieve::Sieve;\n\n let sieve = Sieve::new(30);\n\n assert!(sieve.is_prime(2));\n assert_eq!([(2, 2), (3, 2), (5, 2)], *sieve.factorize(900));\n ```"]
        pub use ::sieve::*;
    }
}
